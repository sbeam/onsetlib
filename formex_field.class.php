<?php
//  formex_fields - PHP class to create form field object for formex
//  Copyright (c) 2000-2004 S.Z.Beam, Onset Corps - sbeam@onsetcorps.net

// +----------------------------------------------------------------------+
//  This file is part of formex.
//
//  formex is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
// 
//  formex is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
// 
//  You should have received a copy of the GNU General Public License
//  along with formex; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
// +----------------------------------------------------------------------+

//!! Class formex_field()
//!  class to create form field object for formex
/*!
    This class provides field objects that represent individual form
    fields within formex. See private function documentation for details on
    each field type - there is one function for each available field type
    within this class.
    */
class formex_field 
{

    /// strs: name of element (dom), fname (name w/ field_prefix)
    var $name, $fname, $field_prefix, $help_text;

    /// arr $attribs holds tag attribs like size,wrap and special formex values like top_value
    var $attribs = array('maxlength'=>'255');

    /// str any extra stuff to be appended to the end of the opening tag (JS event handlers, etc)
    var $extra_attribs = '';

    /// arr linear or str-indexed, holds options for selects, radios, etc - sometimes default values for others
    var $opts = array();

    /// str description or label for the tag
    var $descrip = '';

    /// str which type of element this is - text,password,select,richTextEditor, etc
    var $type = 'text';

    /// str default class attrib for tags
    var $element_class = 'formex';

    /// int one of 3 error states, changes as needed
    var $error_state = FORMEX_FIELD_NOERR;

    /// str holds the html for the tag as generated by the specific method
    var $html = '';

    /// default max size for long elements (text,file,textarea, etc.) used to limit form width
    var $max_size = 30;


    /*!
    \public
    Constructor
    init the element with the given params:
    \in
        \$fex = ref to the parent $formex object - some properties are copied
        \$name = str the name of the element - without the "prefix"
        \$params = arr list w/ up to 6 elements:
                   0 - the element description/label
                   1 - the type of element (text,password,richTextEditor,colorpicker,etc)
                   2 - opts - str or array - depends on type - either a default value param or the list
                       of options for a select/radio/checkarray type field
                   3 - attribs - arr optional name/value pairs of attributes for the tag, varies by type
                   4 - extra_attribs - str any extra stuff to be added to the end of the opening tag
                   ? - last element - if the last elem is a '1' the field will be marked as required (no
                       effect here, used in parent for label display and validation)
    */
    function formex_field(&$fex, $name, $params) 
    {

        // find field 'name' param (and key used throughout)
        $this->fname = $fex->field_prefix . $name;
        $this->max_size = $fex->max_size; // dupe this value, should be universal
        $this->element_class = $fex->element_class; // dupe this value, should be universal
        $this->name = $name;
        $this->fex = &$fex;

        // the label/descrip - not always used
        $this->descrip = $params[0];

        // which type of field
        $this->type = $params[1];

        // required flag is always at the end of the array, and must be a 1
        if ($params[count($params)-1] == FORMEX_FIELD_REQUIRED) {
            $this->set_required();
            array_pop($params);
        }
        elseif ($params[count($params)-1] == FORMEX_FIELD_ERROR) {
            $this->set_error();
            array_pop($params);
        }

        // options for selects, radios. etc., and sometimes default text values...
        // note this can also be set from FEx via 
        // $fex->set_elem_opts('elem_name', array(opt1, opt2, etc));
        if (isset($params[2])) {
            $this->opts = $params[2];
        }

        // the attribs array - anthing in here overrides the default - keys vary by type
        if (isset($params[3]) and is_array($params[3])) {
            $this->attribs = array_merge($this->attribs, $params[3]);
        }

        // the extra_attribs - a string - tacked onto the end of the tag - good for JS event handlers, etc.
        // note this can also be set from FEx via 
        // $fex->set_elem_extra_attribs('elem_name', 'some attribs here');
        if (isset($params[4]) and !empty($params[4])) {
            $this->extra_attribs = $params[4];
        }

    }


    /*!
    \public
    Call the specific method to generate the html for this tag (and any other assoc. stuff)
    and put in $this->html 
    */
    function render_html($fval) 
    {
        $methodname = '_field_' . $this->type;
        if (!method_exists($this, $methodname)) {
            $methodname = "_field_text";
        }
        $this->html = '<span class="formexField' . ucfirst($this->type) . '">';
        $this->html .= $this->$methodname($fval);
        $this->html .= '</span>';
    }


    /*!
    \public
    render the html for the tag and return it
    */
    function get_html($fval) 
    {
        $this->render_html($fval);
        return $this->html;
    }

    /*!
    \public
    set the fixed length of the field as rendered
    (sets the maxlength attrib)
    */
    function set_field_length($len) 
    {
        $this->attribs['maxlength'] = $len;
    }

    /*!
    \public
    set the element as a 'required' field
    has no real effect - can be overridden
    */
    function set_required() 
    {
        $this->error_state = FORMEX_FIELD_REQUIRED;
    }

    /*!
    \public
    set the element to an error state (missing value, etc.)
    has no real effect - can be overridden
    */
    function set_error() 
    {
        $this->error_state = FORMEX_FIELD_ERROR;
    }

    /***** PRIVATE FUNCTIONS BELOW ******/

    /*!
    \private
    processes an array and converts a typical linear-array to a string-indexed
    array where the keys are the same as their values

    the reason for this? for form _elems with arrays of options (select, radio,
    etc), sometimes the name and the value attribs should be the same, and
    sometimes not. If they can be the same, you can pass the opts as a linear
    array, as a shorthand (eg. 'foo', 'bar', 'baz'). If they have to be
    different, pass them as a string-indexed array (eg. name1 => val1, name2
    =>val2). This function will automatically convert a linear array to a
    string-indexed one where each key is the same as its value. This is nutty
    but it lets you use either type of array seamlessly.

    However if you want to use a sequential set of numbers (starting w/ zero)
    as option values then you are screwed. Sorry. Increment them all by 1 or
    something.

    TODO this function is so clever it's stupid. Eventually it will run when an
         array that is not meant to be 'stringified' happens to have a number
         of elements equal to its largest numeric key. Need to enable manual overrides of this.
    */
    function _array_stringify($arr) 
    {
        if (!is_array($arr) or !count($arr)) return $arr;

        $thekeys = array_keys($arr); // get a list of all the keys in the array
        sort($thekeys);              // make sure the biggest one is at the end
        $new_arr = array();

        // if the last element of the keys-list is the same as the number of elements 
        // in $arr, then we assume (ASS, YOU, ME) that is is straight-numeric index,
        // and build onto a new array using the $v as both key and value
        if (($thekeys[count($thekeys)-1] === count($arr)-1)) {
            foreach ($arr as $k => $v) {
                $new_arr[$v] = $v;    // add a new key $v with $v as its value
            }
            return $new_arr;
        }
        else {
            return $arr;
        }
    }


    /*!
    private
    a special 'htmlentities' function which prevents 'double' encoding of the 
    ampersands of already present entities (&gt; => &amp;gt;) - taken from comment
    at http://us4.php.net/manual/en/function.htmlentities.php
    */
    function _htmlentities($str) 
    {
        $transtab=get_html_translation_table (HTML_ENTITIES,ENT_QUOTES);
        $transtab[chr(38)] = '&';
        return preg_replace("/&(?![A-Za-z]{0,4}\w{2,3};|#[0-9]{2,5};)/","&amp;" , strtr($str, $transtab));
    }

    /*!
    private
    finds the proper field size attribute - mostly used for text fields of various types.
    If attribs['size'] is set, use that. Otherwise go to max_size if
    if it more than the maxlength attribute.
    */
    function _get_field_size() 
    {
        if (isset($this->attribs['size'])) {
            return $this->attribs['size'];
        }
        elseif ($this->attribs['maxlength'] > $this->max_size) {
            return $this->max_size;
        }
        else {
            return $this->attribs['maxlength'];
        }
    }

    /*****************************************************************
    **** individual private methods for form field types below: ******
    ******************************************************************/
    
    /*!
    \private
    returns html for a text field
    */
    function _field_text($fval) 
    {
        $fval = (empty($fval) && !empty($this->opts))? $this->opts : $fval;

        return sprintf("<input type=\"text\" id=\"%s\" name=\"%s\" value=\"%s\" size=\"%d\" maxlength=\"%d\" class=\"%s\" %s />\n",
                        $this->fname, 
                        $this->fname, 
                        $this->_htmlentities($fval), 
                        $this->_get_field_size(), 
                        $this->attribs['maxlength'], 
                        (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class,
                        $this->extra_attribs);
    }
    

    /*!
    \private
    returns html for a "number" field - same as text for now 
    TODO JS to check all numeric input
    */
    function _field_number($fval) 
    {
        return $this->_field_text($fval);
    }


    /*! 
    \private
    returns html for a hidden field - can pass default value in $params array slot 2 ("opts")
    */
    function _field_hidden($fval) 
    {

        $myval = (empty($fval) && !empty($this->opts))? $this->opts : $fval;

        return sprintf("<input type=\"hidden\" name=\"%s\" id=\"%s\" value=\"%s\" />",
                       $this->fname,
                       $this->fname,
                       $this->_htmlentities($myval)
                       ) ;
    }



    /*!
    \private
    returns html for a textarea field
    */
    function _field_textarea($fval) 
    {
        $fval = (empty($fval) && !empty($this->opts))? $this->opts : $fval;

        if (!isset($this->attribs['rows'])) {
            $this->attribs['rows'] = 6;
        }
        if (!isset($this->attribs['wrap'])) {
            $this->attribs['wrap'] = 'virtual';
        }
        return sprintf("<textarea %s rows=\"%d\" cols=\"%d\" name=\"%s\" id=\"%s\" class=\"%s\" %s>%s</textarea>",
                        ($this->fex->strict_xhtml_mode)? '' : 'wrap="'.$this->attribs['wrap'].'"',
                        $this->attribs['rows'],
                        $this->max_size,
                        $this->fname,
                        $this->fname,
                        (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class,
                        $this->extra_attribs,
                        $this->_htmlentities($fval));
    }


    /*!
    \private
    returns html for a ordinary file-upload field
    */
    function _field_file($val) 
    {
        $res = "";
        $size = $this->_get_field_size();
        $size -= 12; // compensate for Browse.. button

        if (isset($this->attribs['ws_path'])) {
            $path = $this->attribs['ws_path'];
        }


        $res .= sprintf("<input type=\"file\" name=\"%s\" id=\"%s\" size=\"%d\" maxlength=\"%d\" class=\"%s\" %s/>\n",
                         $this->fname,
                         $this->fname,
                         $size,
                         $this->attribs['maxlength'],
                         (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class,
                         $this->extra_attribs);

        if (isset($this->attribs['show_current']) and !empty($val)) {
            $res .= sprintf('<br /><span style="font-size: 9px">current file: <a href="%s/%s" target="flashWin">%s</a></span>', $path, $val, $val);
        }

        return $res;
    }


	/*!
    \private
    returns html a "heading" - basically just the description - used in display()'ed sometimes
    you prob. want to override this
    */
	function _field_heading($fval) 
    {
        return '<span class="formHeading">' . $this->descrip . '</span>';
	}
	

    /*!
    \private
    returns html for a select box - a common single-choice drop-down
    set 'top_value' in attribs array ($params slot 3) to set the value of the first item (ie 'Choose One...')
    */
    function _field_select($fval) 
    {

        // if need be, copy the current vals for safety + reset()
        $postedvals = (is_array($fval))? $fval : array();

        $res = sprintf("<select size=\"1\" name=\"%s\" id=\"%s\" class=\"%s\" %s>",
                        $this->fname, 
                        $this->fname, 
                        (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class,
                        $this->extra_attribs);

        if (empty($fval) and isset($this->attribs['top_value'])) {
            $res .= "<option value=\"\">". $this->attribs['top_value'] ."</option>"; 
        } 

        $opts = $this->opts; # $this->_array_stringify($this->opts);
        foreach ($opts as $optkey => $optval) { 
            $res .= sprintf("<option value=\"%s\"%s>%s</option>",
                            $this->_htmlentities($optkey),
                            ((in_array($optkey, $postedvals) || $optkey == $fval) and !empty($fval))? " selected" : "",
                            $this->_htmlentities($optval));
        }
        $res .= "</select>";
        return $res;
    }



    /*!
    returns html for a select-box followed by a text-field for "other" vals
    - the text fields name will be "f_name_aux" -
    May be overridden
    */
    function _field_select_or($fval) 
    {

        $aux_val = '';
        $res = '';

        // aux value is set - for useability, dont show anything in the dropdown - and show the valu in the box
        if (!in_array($fval, $this->opts) && !in_array($fval, array_keys($this->opts))) {
            $aux_val = $fval;
            $fval = '';
            $this->attribs['top_value'] = ' ';
        }

        if (count($this->opts) > 0) {
            $res = "choose a previous value: ";
            $res .= $this->_field_select($fval);
            $res .= "<br />or "; 
        }

        // set up new field object for the textares - has '_aux' appended to the name!
        $orsize = $this->_get_field_size() - 15; // comp. for "enter a new one" (can use only w/ single-selects)
        $orfield = new formex_field($this->fex, $this->name.'_aux', array('Aux field', 'text', '', array('size'=>$orsize), null));
        $orfield->render_html($aux_val);

        $res .= "enter a new one:";
        $res .= $orfield->html;
        unset($orfield);
        return $res;
    }


     /*!
    returns html for a select box that allows for multiple selections
    The 'size' attribute for the <SELECT> is passed as array element 'size' in the attribs array (param slot 3)

    $fex->add_element('states', array('Choose some states', 'select_multiple', $states_opts, array('size'=>10)));
    $fex->add_element('friends', array('Your friends:', 'select_multiple', $friends_opts, array('size'=>4));
    
    */
    function _field_select_multiple($fval) 
    {
        // if need be, copy the current vals for safety + reset()
        $postedvals = (is_array($fval))? $fval : array();

        $res = sprintf("<select size=\"%d\"id=\"%s\" name=\"%s\" class=\"%s\" multiple %s >",
                        $this->_get_field_size(),
                        $this->fname,
                        $this->fname . '[]',  // add magic brakets
                        (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class,
                        $this->extra_attribs);

        $opts = $this->opts; # $this->_array_stringify($this->opts);
        foreach ($opts as $optkey => $optval) { 
            $res .= sprintf("<option value=\"%s\"%s>%s</option>",
                            $this->_htmlentities($optkey),
                            (in_array($optkey, $postedvals) || $optkey == $fval)? " selected" : "",
                            $this->_htmlentities($optval));
        }
        $res .= "</select>";
        $res .= sprintf('<br /><span class="%s">%s</span>', 
                         $this->element_class,
                         (isset($this->attribs['help_text']))? $this->attribs['help_text'] : 'Hold down [Ctrl] or [Cmd] to select multiple');
        return $res;
    }
    

    /**
     * returns HTML to create a "Bicameral Selector" or "dueling selects" which is where you
     * have 2 multi-selects and can shuttle items from one to the other w/ JS magic
     * @return HTML
     */
    function _field_select_bicameral($fval)
     {
         // if need be, copy the current vals for safety + reset()
         $postedvals = (is_array($fval))? $fval : array();

         $opts = $this->opts;
         $this->opts = $postedvals;
         $this->attribs['help_text'] = '';
         $pick_label = (isset($this->attribs['pick_button_label']))? $this->attribs[ 'pick_button_label']:'&lt;&lt;';
         $drop_label = (isset($this->attribs['drop_button_label']))? $this->attribs[ 'drop_button_label']:'&gt;&gt;';

         $pool = new formex_field($this->fex, $this->name.'_pool', array('Pool', 'select_multiple', $opts, $this->attribs));
         $op_pick = new formex_field($this->fex, $this->name.'_op_pick', array($pick_label, 'button', null, null, 'onclick="formexFieldBicameralSelect(\''.$this->name. '\', 1)"', 0));
         $op_drop = new formex_field($this->fex, $this->name.'_op_drop', array($drop_label, 'button', null, null, 'onclick="formexFieldBicameralSelect(\''.$this->name. '\', 0)"', 0));

         $res = "<table border=\"0\"><tr><td valign=\"top\">";
         $res .= $this->_field_select_multiple($fval);
         $res .= "</td><td align=\"center\" valign=\"middle\">";
         $res .= $op_pick->get_html(null);
         $res .= $op_drop->get_html(null);
         $res .= "</td><td valign=\"top\">";
         $res .= $pool->get_html(null);
         $res .= "</td></tr></table>\n";
         return $res;
     }

    /*!
    returns html for a set of radio buttons. Enclosed in a simple table - buttons on the right.
    can be overridden if other layouts are needed.
    */
    function _field_radio($fval) 
    {
        $res = "<table border=\"0\">\n";

        $opts = $this->opts; # $this->_array_stringify($this->opts);
        foreach ($opts as $k => $v) {
            $res .= '<tr>';
            $btn = sprintf("<td><input type=\"radio\" value=\"%s\" name=\"%s\" id=\"%s\" class=\"%s\" %s %s /></td>\n",
                            $k,
                            $this->fname,
                            $this->fname,
                            (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class,
                            ($fval !== "" && $fval == $k)? "checked=\"1\"" : "",
                            $this->extra_attribs);

            $label = sprintf("<td align=\"%s\" valign=\"top\"><span class=\"%s\">%s</span></td>",
                            (!empty($this->attribs['buttons_right']))? 'right' : 'left',
                            (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class,
                            $v);

            if (!empty($this->attribs['buttons_right'])) {
                $res .= $label . $btn;
            }
            else {
                $res .= $btn . $label;
            }
            $res .= '</tr>';

        }
        $res .= "</table>\n\n";
        return $res;
    }


    /*!
    returns html for a lone checkbox. 
    default value is the browser default ("on") - to change this set the $opts param to your string (param slot 2)
    Says "Check for yes" afterwards - to change this text, set attribs value 'after_text'
    */
    function _field_toggle($fval) 
    {
        return sprintf("<input type=\"checkbox\" name=\"%s\" id=\"%s\" %s class=\"%s\" %s %s />&nbsp;<span class=\"%s\">%s</span>",
                        $this->fname,
                        $this->fname,
                        ($this->opts)? 'value="' . $this->opts . '"' : '',
                        (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class,
                        (!empty($fval) && $fval != '0000-00-00')? "checked" : "",
                        $this->extra_attribs,
                        (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class,
                        (isset($this->attribs['after_text']))? $this->attribs['after_text'] : '(Check for yes)' 
                        );
    }

    /*!
    same as _field_toggle but without the "Check for yes" business
    */
    function _field_checkbox($fval) 
    {
        return sprintf("<input type=\"checkbox\" name=\"%s\" id=\"%s\" %s class=\"%s\" %s %s />",
                        $this->fname,
                        $this->fname,
                        ($this->opts)? 'value="' . $this->opts . '"' : '',
                        (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class,
                        (!empty($fval) && $fval != '0000-00-00')? "checked" : "",
                        $this->extra_attribs);
    }



    /*!
    returns html for an array of checkboxes - includes its own complete inner
    table. Thats why the detection of $or_field is done here, so the "Other" field
    can go in the same table. Otherwise this just returns a 2-column table, with
    the checkboxes on the right
    */
    function _field_checkarray($fval, $or_field=0) 
    {
        $res = "<table border=\"0\">\n";
        if (is_array($fval)) {
            $postedvals = $fval;  // copy the current vals for safety + reset()
        }
        else {
            $postedvals = array(); // make an empty arry
        }

        $other_was = '';

        $opts = $this->opts; # $this->_array_stringify($this->opts);
        if ($or_field) {  // this was called as field_checkarray_or(), look for the "Other" field vals
            while( $a_each = each($postedvals) ) {
                $v = $a_each["value"];
                if (!$opts[$v]) {       // they had filled out the "Other" text field,
                    $other_was = $v;    // so we save it for re-display this go-round
                }
            }
        }
        $classname = (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class;
        foreach ($opts as $k => $txt) { // (reset($opts); $txt=current($opts); next($opts) ) {
            $res .= sprintf("<tr><td align=\"right\"><span class=\"%s\">%s</span></td>
                             <td align=\"left\"><input type=\"checkbox\" value=\"%s\" name=\"%s[]\" class=\"%s\" %s %s /></td></tr>\n",
                            $classname, 
                            $txt,
                            $k,
                            $this->fname,
                            $classname,
                            (in_array($k, $postedvals))? "checked" : "",
                            $this->extra_attribs);
        }
        if ($or_field) { // now put the "Other" text field
            $res .= sprintf("<tr><td align=\"right\" valign=\"middle\">
                                    <span class=\"%s\">Other:</span></td>\n<td>\n",
                            $classname);

            $othersize = $this->_get_field_size - 15; // comp. for table width
            $other = new formex_field($this->fex, $this->name.'[]', array('Other field', 'text', 1, array('size'=>$othersize)));
            $other->render_html($other_was);
            $res .= $other->html;
            unset($other);
        }
        $res .= "</td></tr></table>\n\n";
        return $res;
    }


    /*!
    returns html for a checkbox array, with an optional "Other" text field below
    similar to field_select_or() above - although this method only calls
    field_checkarray() but sets the $or_field param to true
    */
    function _field_checkarray_or($fval) 
    {
        return $this->_field_checkarray($fval, 1);
    }


    /*!
    returns html for date-input fields - two selects (month, day) and for year,
    either another select or a length-4 text depending on whether $opts is set.
    If so, the year drop down will contain $opts years, sequential and
    inclusive of the current year. So there.

    no error checking or auto-concatination is done (currently)
    its expected to deal w/ these in the handler script, you will have
    f_name_day, f_name_month and f_name_year params

    useful attributes to set (3rd colmap array index):
      year_begin : int year to begin with (current year by default)
      year_end : int year to end with (current year by default)
               or - +X meaning year_begin +X
                  - now+X meaning current year +X
      suppress_day : bool dont show the day selector (just month and year)

    (if neither year_end or year_begin is set, a 4-char text field will be
    given for the year input, allowing total freeform year entry)

    $fval should be in international/SQL92 compliant YYYY-MM-DD format
    */
    function _field_date($fval) 
    {
        // if $fval is not already split up, we assume std. date string // YYYY-MM-DD
        if (is_array($fval)) {
            $f_date = &$fval;
        }
        elseif ($fval) {
            $f_date = split('-', $fval, 3);
        }
        else {
            $f_date = array('','','');
        }

        $res = "<span id=\"" . $this->name . "\">";

        for ($i=1; $i<32; $i++) { $days[sprintf("%02d", $i)] = $i; }

        $months_abbr = array("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec");
        for ($i=1; $i<13; $i++) { $months[sprintf("%02d", $i)] = $months_abbr[$i-1]; }

        $fmonths = new formex_field($this->fex, $this->name.'_month', array('Months', 'select', $months));
        $res .= $fmonths->get_html($f_date[1]);

        if (isset($this->attribs) and !isset($this->attribs['suppress_day'])) {
            $fdays = new formex_field($this->fex, $this->name.'_day', array('Dates', 'select', $days));
            $res .= $fdays->get_html($f_date[2]);
        }

        $year_range = null;
        $this_year = date('Y');
        if (isset($this->opts) and is_numeric($this->opts)) { // int val will be this year +
            $year_range = $this->_array_stringify(range($this_year, $this_year+$this->opts));
        }
        elseif (isset($this->attribs) && is_array($this->attribs)) { // exact range specified
            $begin = (isset($this->attribs['year_begin']))? $this->attribs['year_begin'] : $this_year;
            $end = $this_year;
            if (isset($this->attribs['year_end'])) {
                if (substr($this->attribs['year_end'], 0, 4) == 'now+') {
                    $end = $this_year + intval(substr($this->attribs['year_end'], 4));
                }
                elseif (substr($this->attribs['year_end'], 0, 4) == 'now-') {
                    $end = $this_year - intval(substr($this->attribs['year_end'], 4));
                }
                elseif (substr($this->attribs['year_end'], 0, 1) == '+') {
                    $end = $begin + intval(substr($this->attribs['year_end'], 1));
                }
                elseif (substr($this->attribs['year_end'], 0, 1) == '-') {
                    $end = $begin - intval(substr($this->attribs['year_end'], 1));
                }
                else {
                    $end = intval($this->attribs['year_end']);
                }
            }

            if ($begin != $end) {
                $year_range = $this->_array_stringify(range($begin, $end));
            }
        }

        if ($year_range) { // dropdown w/ that range
            $fyears = new formex_field($this->fex, $this->name.'_year', array('Years', 'select', $year_range));
        }
        else { // 4-space text field
            $fyears = new formex_field($this->fex, $this->name.'_year', array('Years', 'text', null, array('size'=>4)));
        }
        $res .= $fyears->get_html($f_date[0]);
        unset($fmonths, $fdays, $fyears);
        $res .= "</span>";

        return $res;
    }


    /*!
    same as field_date but expects input in MM/DD/YYYY US format
    */
    function _field_date_us($fval) 
    {
        $f_date = "";
        if ($fval) {
            list($m,$d,$y) = split('/', $fval);
            $f_date = array($y, $m, $d);
        }
        return $this->_field_date($f_date);
    }

    /**
     * display a popup calendar widget using the dynarch JS code
     * http://www.dynarch.com/projects/calendar/
     * TODO allow choice of styles via attribs, and choice of date ranges, date formats, etc
     */
    function _field_calendar($fval) 
    {

        $dir = $this->fex->extra_js_src_dir . '/dynarchCalendar';

        if (!isset($this->attribs['format'])) {
             $fmt = (isset($this->attribs['showtime']))? "%d %b %Y %I:%M %p" : "%d %b %Y";
        }
        else {
            $fmt = $this->attribs['format'];
        }
        $phpfmt = strtr($fmt, 'bpMI', 'MAih');
        $phpfmt = str_replace('%', '', $phpfmt);
        $dateval = ($fval)? date($phpfmt, strtotime($fval)) : '';

        $showtime = (isset($this->attribs['showtime']))? 'true' : 'false'; // note intentional strings
        $class = (isset($this->attribs['showtime']))? 'formexCalendarInputTime' : 'formexCalendarInput'; // note intentional strings
        $setup_args = "'$fmt', $showtime";

        // vanilla text field where the date is placed...
        $text = new formex_field($this->fex, $this->fname, array(null, 'text', null, array('class'=>"$class magic"), 'onmouseover="initCalendarSetup(this, '.$setup_args.')" readonly="true"', null));
        $res = $text->get_html($dateval);

        return $res;
    }

    /** like field_date but adds the time component.
     * additional attributes: 
     *              seconds - bool include the seconds component (default false)
     *              ampm - use 12-hr time format and include AM/PM selector (default false)
     * 
     */
    function _field_datetime($fval) 
    {
        $f_date = "";
        $f_time = "";
        // expect value in "2004-12-27 13:30:00" format
        if ($fval and preg_match('/^([\d-]+) ([\d:]+)/', $fval, $m)) {
            $f_date = $m[1];
            $f_time = $m[2];
        }
        $res = $this->_field_date($f_date);
        
        list ($h, $m, $s) = explode(':', $f_time);

        if (isset($this->attribs['ampm'])) {
            $is_pm = false;
            if ($h > 12) {
                $h -= 12;
                $is_pm = true;
            }
        }

        $res .= '<span class="fieldDatetimeTime">&nbsp;&nbsp;&nbsp;';
        $f = new formex_field($this->fex, $this->name.'_hours', array('hours', 'text', null, array('size'=>2)));
        $res .= $f->get_html($h);

        $f = new formex_field($this->fex, $this->name.'_min', array('minutes', 'text', null, array('size'=>2)));
        $res .= ':&nbsp;' . $f->get_html($m);

        if (isset($this->attribs['seconds'])) {
            $f = new formex_field($this->fex, $this->name.'_sec', array('seconds', 'text', null, array('size'=>2)));
            $res .= ':&nbsp;' . $f->get_html($s);
        }
        if (isset($this->attribs['ampm'])) {
            $f = new formex_field($this->fex, $this->name.'_ampm', array('seconds', 'select', array('AM'=>'AM', 'PM'=>'PM'), null));
            $res .= $f->get_html(($is_pm)?'PM':'AM');
        }
        $res .= '</span>';

        return $res;
    }

    /**
     * field for an AJAX-style autocomplete form. Pretty simple eh?
     *
     * all the javascript is in formex_extras.js. Server-side response is up to
     * you - right now the HTTPRequest object sends a request to the URL
     * [document.location + "&formexAC=xyz"] whenever a key is pressed in the
     * textarea. It expects a simple XML response that looks like
     * 
     * <matches><item id="123">Something that matched</item></matches>
     * 
     * where id attrib of item is used as the key value that is submitted with
     * the form (similar to how a <SELECT> tag works)
     */
    function _field_autocomplete($fval)
    {
        $res = '<div class="formexACPositioner" style="position: relative">';
        $res .= $this->_field_hidden($fval);

        $extra = $this->extra_attribs . ' autocomplete="off" onkeyup="formexACDoCompletion(this)" onblur=""';
        $text = new formex_field($this->fex, $this->fname.'ACInput', array(null, 'text', null, null, $extra, null));
        $res .= $text->get_html(null);

        $res .= '</div>';
        $res .= '<div name="'.$this->fname.'" id="formexACMenuPopup-'.$this->fname.'" class="formexACMenuPopup" style="position: absolute;"><div class="formexACSelectInner"></div></div>';
        return $res;
    }

    /*!
        same as _field_text but size is always 2 - this hints to users they
        should put their 2-letter state abbr. but lets them put NSW if they
        live in Australia, or whatever the case may be
    */
    function _field_state_abbr($fval) 
    {
        $this->attribs['size'] = 2;
        return $this->_field_text($fval);
    }


    /*!
        returns a SELECT populated with all the worlds countries - hey, you're GLOBALIZED!
    */
    function _field_country_select($fval) 
    {
        $do_codes = (isset($this->attribs) and isset($this->attribs['iso_codes']));

        $limit_to = null;
        if (isset($this->attribs) and isset($this->attribs['limit_to'])) {
            $limit_to = $this->attribs['limit_to'];
        }
        $c = $this->_get_countries($do_codes, null, $limit_to);
        $this->opts = $this->_array_stringify($c);
        return $this->_field_select($fval);
    }


    /*!
        returns a SELECT populated with all the US states (and Canada provs too, optionally)
    */
    function _field_state_select($fval) 
    {
        $abbrs = (!isset($this->attribs) or !isset($this->attribs['abbrs']) or $this->attribs['abbrs'] != false);
        if (isset($this->attribs) and isset($this->attribs['canada'])) {
            $this->opts = $this->get_states_opts($abbrs) + $this->get_canadian_provs($abbrs);;
        }
        else {
            $this->opts = $this->get_states_opts($abbrs);
        }
        return $this->_field_select($fval);
    }


    /*!
    \private
        returns html for a read-only form field - really just a text label - and a
        hidden field with the given name and value, to fool the censors on the processing side
    */
    function _field_readonly($fval) 
    {
        $fval = (empty($fval) && !empty($this->opts))? $this->opts : $fval;

        $res = sprintf("<span class=\"%s\">%s</span>\n", 
                       (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class,
                       $this->_htmlentities($fval));
        $res .= $this->_field_hidden($fval);
        return $res;
    }

    /*!
    \private
    returns html for a password field
    */
    function _field_password($fval) 
    {
        return sprintf("<input type=\"password\" name=\"%s\" id=\"%s\" value=\"%s\" size=\"%d\" maxlength=\"%d\" class=\"%s\" />\n",
                        $this->fname,
                        $this->fname,
                        $this->_htmlentities($fval),
                        $this->_get_field_size(),
                        $this->attribs['maxlength'],
                        (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class);
    }


    /*!
    \private
    returns html for a submit button, and optionally, the reset button (if
    show_reset_button attrib is set)

    */
    function _field_submit($fval) 
    {
        $res = "";
        if (isset($this->attribs['disable_self_onclick'])) {
            $this->extra_attribs .= 'onclick="this.disabled=true; this.value=\'please wait...\'"';
        }

        if (isset($this->attribs['show_reset_button'])) {
            $res .= sprintf("<div style=\"float:left\"><input type=\"reset\" name=\"reset_op\" value=\"reset form\" class=\"%s\" /></div>\n", 
                        (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class);
        }
        $res .= sprintf("<input type=\"submit\" name=\"%s\" id=\"%s\" value=\"%s\" class=\"%s\" %s />\n",
                        $this->fname,
                        $this->fname,
                        $this->_htmlentities($this->descrip),
                        (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class,
                        $this->extra_attribs);
        return $res;
    }

     /*!
     \private
     returns html for a HTML 4.0 button
     */
     function _field_button($fval)
     {
         $res = "";
         if (isset($this->attribs['disable_self_onclick'])) {
             $this->extra_attribs .= 'onclick="this.disabled=true; this.value=\'please wait...\'"';
         }

         $res .= sprintf("<input type=\"button\" name=\"%s\" id=\"%s\" value=\"%s\" class=\"%s\" %s />\n",
                         $this->fname,
                         $this->fname,
                         $this->_htmlentities($this->descrip),
                         (isset($this->attribs['class']))? $this->attribs['class'] : $this->element_class,
                         $this->extra_attribs);
         return $res;
     }



######## EXTRAS:

    function _field_captcha($val) {
        $phrasefield = new formex_field($this->fex, $this->name, array('for the phrase', 'text', 1, array('size'=>$this->attribs['text_length'])));
        $res = $phrasefield->get_html($fval);

        $res .= '<div id="captchaHelp">';
        $res .= $this->attribs['help_text'];
        $res .= ' [<a href="#" onclick="toggleCaptchaHelp(); return false">close</a>]</div>';

        return $res;
    }

    /*!
    \private
    sets up some DIVs, IMFRAMEs and JavaScript tags to create the x-browser Rich Text Editor,
    http://www.kevinroth.com/rte/demo.htm
    a textarea replacement. Most of the HTML is written using document.write() in richTextEditor.js -
    this file must be located where $this->js_src_dir says it is!
    */
    function _field_richTextEditor($fval) 
    {
        $themes = array('mceAdvanced', 'mceSimple');
        if (!empty($this->attribs['theme']) && in_array($this->attribs['theme'], $themes)) {
            $theme = $this->attribs['theme'];
        }
        else {
            $theme = $themes[0];
        }

        $cols = (!empty($this->attribs['cols']))? $this->attribs['cols'] : 85;
        $rows = (!empty($this->attribs['rows']))? $this->attribs['rows'] : 10;

        $res = sprintf("<textarea id=\"%s\" name=\"%s\" rows=\"%d\" cols=\"%d\" class=\"%s\">%s</textarea>",
                       $this->fname, $this->fname,
                       $rows,
                       $cols,
                       $theme,
                       $this->_htmlentities($fval));

        return $res;
    }


    /*!
        builds little RGB color picker field with a nice swatch to show the current
        color, and a pop-up div to select a new one. needs JS functions to operate:
    */
    function _field_colorpicker($fval) 
    {

        $this->attribs['size'] = 7;
        $res = $this->_field_text($fval);

        $name = $this->fname;

        $res .= sprintf("<span id=\"swatch_%s\" style=\"border: 2px solid black; background-color: %s\">
                        <a href=\"#\" onclick=\"cp_displayToggle('palette_%s'); return false;\" style=\"text-decoration:none\">
                         &nbsp;&nbsp;&nbsp;&nbsp;</a></span>",
                         $name, $fval, $name);
        $res .= <<<EOJS
        <div id="palette_$name" style="display:none; position: absolute; z-index: 11; background: #ddd;">
        <script type="text/javascript">
        document.forms[0].$name.onchange = function () { document.getElementById('swatch_$name').style.background = this.value }

        var total = colors.length;
        var width = 18;
        var cp_contents = "";
        cp_contents += '<table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">';
        var use_highlight = (document.getElementById || document.all)?true:false;
        for (var i=0; i<total; i++) {
            if ((i % width) == 0) { cp_contents += "<tr>"; }
            if (use_highlight) { var mo = 'onMouseOver="cp_highlightColor(\''+colors[i]+'\',\'$name\')"'; }
            else { mo = ""; }
            cp_contents += '<td bgcolor="'+colors[i]+'"><span style="font-size:0.75em"><a href="#" onclick="cp_selectColor(\''+colors[i]+'\',\'$name\');return false;" '+mo+' style="text-decoration:none;">&nbsp;&nbsp;&nbsp;</a></span></td>';
            if ( ((i+1)>=total) || (((i+1) % width) == 0)) { 
                cp_contents += "</tr>";
            }
        }

        if (document.getElementById) {
            cp_contents += '<tr><td colspan="'+width+'">';
            cp_contents += '<div style="width:48%; border: 1px solid #ddd; float: left; background-color: #fff" id="cp_SelectedColor_$name">&nbsp;</div>';
            cp_contents += '<div style="width:48%; border: 1px solid #ddd; float: right; background-color: #fff" id="cp_SelectedColorValue_$name">#ffffff</div>';
            cp_contents += '</td></tr>';
        }
        cp_contents += "</table>";
        document.write(cp_contents);

        </script>
        </div>
EOJS;
        return $res;
    }




    /*!
    \private
    shows a file upload field, but if $val is set shows an icon for the image itself.
    When the icon is clicked it should display the actual image file that is the current value of this field
    */
    function _field_image_upload ($val) 
    {

        $name = $this->fname;
        $path = '';

        if (isset($this->attribs['ws_path'])) {
            $path = $this->attribs['ws_path'];
        }
        elseif (defined('SITE_MEDIA_URLPATH')) {
            $path = SITE_MEDIA_URLPATH;
        }

        $res = "<div class=\"displayWrapper\" style=\"position: relative; margin: 0; padding: 0\">\n";

        if (!empty($val)) {
            if (is_array($val)) { // tis inside an expandable fieldset holy shit
                $res .= "<a href=\"#\" onclick=\"autoDisplayToggle(event); return false;\">
                            <img src=\"".$this->fex->icons_dir."image2.gif\" height=\"22\" width=\"20\" border=\"0\" /></a>
                            <div style=\"position: absolute; left: 0px; top: 0px; display: none; z-index: 12\">";
                $res .= sprintf("<a href=\"#\" onclick=\"autoDisplayToggle(event); return false;\"> 
                                <img class=\"sampleImgExpander\" name=\"img_sample_$name\" src=\"%s/%s\" %s border=\"0\" /></a>\n ",
                                 $path,
                                 $val["${name}_orig"], 
                                 $val["${name}_orig_dims"]);
                $res .= sprintf('<input type="hidden" name="%s_orig" value="%s" />', $name, $val["${name}_orig"]);
                $res .= sprintf('<input type="hidden" name="%s_orig_dims" value="%s" />', 
                                 $name, 
                                 $this->_htmlentities($val["${name}_orig_dims"]));
            }
            else { // tis just a wee little regular file field matey
                $val = preg_replace('/^\//', '', $val); // rid of a pesky leading slash now
                if (preg_match('/\.swf$/', $val)) { // its a F'en Flash - just pop a new friggin windowz
                    $res .= "<a href=\"$path/$val\" target=\"flashWin\">
                                <img src=\"/gfx/icons/flash.gif\" height=\"25\" width=\"25\" border=\"0\"></a>";
                }
                else {
                    $res .= "<a href=\"#\" onclick=\"autoDisplayToggle('Wrap$name'); return false;\">
                                <img src=\"".$this->fex->icons_dir."image2.gif\" height=\"22\" width=\"20\" border=\"0\" /></a>
                        <div id=\"Wrap$name\" style=\"position: absolute; left: 0px; top: 0px; display: none; z-index: 12\">
                        <a href=\"#\" onclick=\"autoDisplayToggle('Wrap$name'); return false;\">";
                    $res .= "
                          <img src=\"$path/$val\" border=\"0\" /></a>";
                }
            }
            $res .= "</div>";
        }

        $res .= $this->_field_file($val);
        $res .= "</div>";
        return $res;
    }

   
    /*!
    \private
    sets up a small "subform" in a <fieldset> tag which thanks to the magic of DOM manipulation
    can be duplicated WITHIN the mainform. Thus you can have variable arbitrary numbers of sets of
    fields. More info to come.
    */
    function _field_expandable_fieldset ($fval) 
    {

        $res = '';
        $setName = $this->name;

        // how many sets to show to begin w/?
        if (!empty($fval) and is_array($fval)) {
            $numsets = count($fval);
        }
        elseif (isset($this->attribs['numsets'])) {
            $numsets = $this->attribs['numsets'];
        }
        else {
            $numsets = 1;
        }

        /* suss out attribs */
        if (!isset($this->attribs['fieldset_control_pos'])) $this->attribs['fieldset_control_pos'] = 'bottom';
        if (!isset($this->attribs['lang_num_fieldsets'])) $this->attribs['lang_num_fieldsets'] = '# Fieldsets';

        /* $fval should be a list of hashes - each elem belongs to a fieldset,
         * the name=>value pairs are the default values for each field w/in
         * that set */
        $res .= "<script language=\"javascript\" type=\"text/javascript\">
                <!--
                expandableList[expandableList.length] = '$setName';
                var vals$setName = new Array();
                ";

        for ($i = 0; $i < $numsets; $i++) {
            $res .= "vals$setName"."[$i] = new Object;\n";
            if (isset($fval[$i])) {
                foreach ($fval[$i] as $subname => $val) {
                    $res .= sprintf("    vals%s[%d].%s%s = '%s';\n",
                                    $setName,
                                    $i,
                                    $this->field_prefix,
                                    $subname,
                                    preg_replace("/'/", "\\'", $val));
                }
            }
        }

        $res .= '
                // -->
                </script>
                ';

        $hiddens = '';
        $res .= '<div id="readroot_'.$setName.'" style="display: none; margin:0; padding: 0">';
        $res .= '<fieldset class="'.$this->element_class.'">';
        $res .= $this->fex->table_start();

        foreach ($this->opts as $name => $parms) {
                $newelem = new formex_field($this->fex, $name, $parms);

                // get the form element from the approved method
                if ($newelem->type != 'hidden') { // add html to hiddens string and get out
                    $res .= $this->fex->table_row_begin();
                    $res .= $this->fex->field_label($newelem);
                    $res .= $this->fex->table_row_middle();
                    $res .= $newelem->get_html('');
                    $res .= $this->fex->table_row_end();
                }
                else {
                    $hiddens = $newelem->get_html('');
                }
                unset($newelem);
        }

        $res .= $hiddens;
        $res .= '</tr></table>
                 </fieldset>
                 </div>';

        if ($this->attribs['fieldset_control_pos'] == 'top' or $this->attribs['fieldset_control_pos'] == 'both') {
            $res .= $this->_exp_fieldset_control($setName, $this->attribs['lang_num_fieldsets']);
        }

        $res .= '<span id="writeroot_'.$setName.'"></span>';

        if ($this->attribs['fieldset_control_pos'] == 'bottom' or $this->attribs['fieldset_control_pos'] == 'both') {
            $res .= $this->_exp_fieldset_control($setName, $this->attribs['lang_num_fieldsets']);
        }

        // $res .= $this->_field_hidden("f_count_$setName", count($fval));
        $hidcnt = new formex_field($this->fex, 'count_'.$setName, array('count', 'hidden'));
        $res .= $hidcnt->get_html($numsets);

        return $res;
    }

function _exp_fieldset_control($setName, $lang = '# Fieldsets') {
        $res = sprintf('<span id="fieldsetControl%s" class="formexFieldsetControllers %s">', $setName, $this->element_class);
        $res .= $lang . '
                 <a href="#" onclick="moreFields(\''.$setName.'\'); return false" >+</a>&nbsp;/&nbsp;';
        $res .= '<a href="#" onclick="lessFields(\''.$setName.'\'); return false" >&ndash;</a>
                 </span>';
        return $res;
}



/*********** static functions - DATA type stuff ******************/

     /* get a list of all the countries in the world
      * @param $iso bool if true, return ISO codes as keys and country names as values
      * @param $code str opt return the contry name matching the ISO code given by $code
      * @param $limit array opt limit the results to the ISO codes in $limit
      * @return array or string if $code is set
      */
     /* static */ function _get_countries($iso=false, $code=null, $limit=null) 
     {

        $cc = array(
            'US' =>  	'United States',
            'CA' =>  	'Canada',
            'AF' =>  	'Afghanistan',
            'AX' =>  	'land Islands',
            'AL' =>  	'Albania',
            'DZ' =>  	'Algeria',
            'AS' =>  	'American Samoa',
            'AD' =>  	'Andorra',
            'AO' =>  	'Angola',
            'AI' =>  	'Anguilla',
            'AG' =>  	'Antigua and Barbuda',
            'AR' =>  	'Argentina',
            'AM' =>  	'Armenia',
            'AW' =>  	'Aruba',
            'AU' =>  	'Australia',
            'AT' =>  	'Austria',
            'AZ' =>  	'Azerbaijan',
            'BS' =>  	'Bahamas',
            'BH' =>  	'Bahrain',
            'BD' =>  	'Bangladesh',
            'BB' =>  	'Barbados',
            'BY' =>  	'Belarus',
            'BE' =>  	'Belgium',
            'BZ' =>  	'Belize',
            'BJ' =>  	'Benin',
            'BM' =>  	'Bermuda',
            'BT' =>  	'Bhutan',
            'BO' =>  	'Bolivia',
            'BA' =>  	'Bosnia and Herzegovina',
            'BW' =>  	'Botswana',
            'BR' =>  	'Brazil',
            'IO' =>  	'British Indian Ocean Territory',
            'BN' =>  	'Brunei Darussalam',
            'BG' =>  	'Bulgaria',
            'BF' =>  	'Burkina Faso',
            'BI' =>  	'Burundi',
            'KH' =>  	'Cambodia',
            'CM' =>  	'Cameroon',
            'CA' =>  	'Canada',
            'CV' =>  	'Cape Verde',
            'KY' =>  	'Cayman Islands',
            'CF' =>  	'Central African Republic',
            'TD' =>  	'Chad',
            'CL' =>  	'Chile',
            'CN' =>  	'China, People\'s Republic of',
            'CX' =>  	'Christmas Island',
            'CC' =>  	'Cocos (Keeling) Islands',
            'CO' =>  	'Colombia',
            'KM' =>  	'Comoros',
            'CD' =>  	'Congo',
            'CK' =>  	'Cook Islands',
            'CR' =>  	'Costa Rica',
            'CI' =>  	'Cte d\'Ivoire',
            'HR' =>  	'Croatia',
            'CU' =>  	'Cuba',
            'CY' =>  	'Cyprus',
            'CZ' =>  	'Czech Republic',
            'DK' =>  	'Denmark',
            'DJ' =>  	'Djibouti',
            'DM' =>  	'Dominica',
            'DO' =>  	'Dominican Republic',
            'EC' =>  	'Ecuador',
            'EG' =>  	'Egypt',
            'SV' =>  	'El Salvador',
            'GQ' =>  	'Equatorial Guinea',
            'ER' =>  	'Eritrea',
            'EE' =>  	'Estonia',
            'ET' =>  	'Ethiopia',
            'FK' =>  	'Falkland Islands',
            'FO' =>  	'Faroe Islands',
            'FJ' =>  	'Fiji',
            'FI' =>  	'Finland',
            'FR' =>  	'France',
            'GF' =>  	'French Guiana',
            'PF' =>  	'French Polynesia',
            'TF' =>  	'French Southern Territories',
            'GA' =>  	'Gabon',
            'GM' =>  	'Gambia',
            'GE' =>  	'Georgia',
            'DE' =>  	'Germany',
            'GH' =>  	'Ghana',
            'GI' =>  	'Gibraltar',
            'GR' =>  	'Greece',
            'GL' =>  	'Greenland',
            'GD' =>  	'Grenada',
            'GP' =>  	'Guadeloupe',
            'GU' =>  	'Guam',
            'GT' =>  	'Guatemala',
            'GN' =>  	'Guinea',
            'GW' =>  	'Guinea-Bissau',
            'GY' =>  	'Guyana',
            'HT' =>  	'Haiti',
            'HN' =>  	'Honduras',
            'HK' =>  	'Hong Kong',
            'HU' =>  	'Hungary',
            'IS' =>  	'Iceland',
            'IN' =>  	'India',
            'ID' =>  	'Indonesia',
            'IR' =>  	'Iran',
            'IQ' =>  	'Iraq',
            'IE' =>  	'Ireland',
            'IL' =>  	'Israel',
            'IT' =>  	'Italy',
            'JM' =>  	'Jamaica',
            'JP' =>  	'Japan',
            'JO' =>  	'Jordan',
            'KZ' =>  	'Kazakhstan',
            'KE' =>  	'Kenya',
            'KI' =>  	'Kiribati',
            'KP' =>  	'Korea, DPR',
            'KR' =>  	'Korea, Republic of',
            'KW' =>  	'Kuwait',
            'KG' =>  	'Kyrgyzstan',
            'LA' =>  	'Lao People\'s Democratic Republic',
            'LV' =>  	'Latvia',
            'LB' =>  	'Lebanon',
            'LS' =>  	'Lesotho',
            'LR' =>  	'Liberia',
            'LY' =>  	'Libyan Arab Jamahiriya',
            'LI' =>  	'Liechtenstein',
            'LT' =>  	'Lithuania',
            'LU' =>  	'Luxembourg',
            'MO' =>  	'Macao',
            'MK' =>  	'Macedonia',
            'MG' =>  	'Madagascar',
            'MW' =>  	'Malawi',
            'MY' =>  	'Malaysia',
            'MV' =>  	'Maldives',
            'ML' =>  	'Mali',
            'MT' =>  	'Malta',
            'MH' =>  	'Marshall Islands',
            'MQ' =>  	'Martinique',
            'MR' =>  	'Mauritania',
            'MU' =>  	'Mauritius',
            'YT' =>  	'Mayotte',
            'MX' =>  	'Mexico',
            'FM' =>  	'Micronesia',
            'MD' =>  	'Moldova',
            'MC' =>  	'Monaco',
            'MN' =>  	'Mongolia',
            'MS' =>  	'Montserrat',
            'MA' =>  	'Morocco',
            'MZ' =>  	'Mozambique',
            'MM' =>  	'Myanmar',
            'NA' =>  	'Namibia',
            'NR' =>  	'Nauru',
            'NP' =>  	'Nepal',
            'NL' =>  	'Netherlands',
            'AN' =>  	'Netherlands Antilles',
            'NC' =>  	'New Caledonia',
            'NZ' =>  	'New Zealand',
            'NI' =>  	'Nicaragua',
            'NE' =>  	'Niger',
            'NG' =>  	'Nigeria',
            'NU' =>  	'Niue',
            'NF' =>  	'Norfolk Island',
            'MP' =>  	'Northern Mariana Islands',
            'NO' =>  	'Norway',
            'OM' =>  	'Oman',
            'PK' =>  	'Pakistan',
            'PW' =>  	'Palau',
            'PS' =>  	'Palestinian Territory, Occupied',
            'PA' =>  	'Panama',
            'PG' =>  	'Papua New Guinea',
            'PY' =>  	'Paraguay',
            'PE' =>  	'Peru',
            'PH' =>  	'Philippines',
            'PN' =>  	'Pitcairn',
            'PL' =>  	'Poland',
            'PT' =>  	'Portugal',
            'PR' =>  	'Puerto Rico',
            'QA' =>  	'Qatar',
            'RE' =>  	'Runion',
            'RO' =>  	'Romania',
            'RU' =>  	'Russian Federation',
            'RW' =>  	'Rwanda',
            'SH' =>  	'Saint Helena',
            'KN' =>  	'Saint Kitts and Nevis',
            'LC' =>  	'Saint Lucia',
            'PM' =>  	'Saint-Pierre and Miquelon',
            'VC' =>  	'Saint Vincent and the Grenadines',
            'WS' =>  	'Samoa',
            'SM' =>  	'San Marino',
            'ST' =>  	'So Tom and Prncipe',
            'SA' =>  	'Saudi Arabia',
            'SN' =>  	'Senegal',
            'CS' =>  	'Serbia and Montenegro',
            'SC' =>  	'Seychelles',
            'SL' =>  	'Sierra Leone',
            'SG' =>  	'Singapore',
            'SK' =>  	'Slovakia',
            'SI' =>  	'Slovenia',
            'SB' =>  	'Solomon Islands',
            'SO' =>  	'Somalia',
            'ZA' =>  	'South Africa',
            'ES' =>  	'Spain',
            'LK' =>  	'Sri Lanka',
            'SD' =>  	'Sudan',
            'SR' =>  	'Suriname',
            'SJ' =>  	'Svalbard and Jan Mayen',
            'SZ' =>  	'Swaziland',
            'SE' =>  	'Sweden',
            'CH' =>  	'Switzerland',
            'SY' =>  	'Syrian Arab Republic',
            'TW' =>  	'Taiwan',
            'TJ' =>  	'Tajikistan',
            'TZ' =>  	'Tanzania',
            'TH' =>  	'Thailand',
            'TL' =>  	'Timor-Leste',
            'TG' =>  	'Togo',
            'TK' =>  	'Tokelau',
            'TO' =>  	'Tonga',
            'TT' =>  	'Trinidad and Tobago',
            'TN' =>  	'Tunisia',
            'TR' =>  	'Turkey',
            'TM' =>  	'Turkmenistan',
            'TC' =>  	'Turks and Caicos Islands',
            'TV' =>  	'Tuvalu',
            'UG' =>  	'Uganda',
            'UA' =>  	'Ukraine',
            'AE' =>  	'United Arab Emirates',
            'GB' =>  	'United Kingdom',
            'US' =>  	'United States',
            'UY' =>  	'Uruguay',
            'UZ' =>  	'Uzbekistan',
            'VU' =>  	'Vanuatu',
            'VA' =>  	'Vatican City State',
            'VE' =>  	'Venezuela',
            'VN' =>  	'Viet Nam',
            'VG' =>  	'Virgin Islands, British',
            'VI' =>  	'Virgin Islands, U.S.',
            'WF' =>  	'Wallis and Futuna',
            'EH' =>  	'Western Sahara',
            'YE' =>  	'Yemen',
            'ZM' =>  	'Zambia',
            'ZW' =>  	'Zimbabwe',);

        if ($limit && is_array($limit)) {
            foreach (array_keys($cc) as $iso) {
                if (!in_array($iso, $limit)) {
                    unset($cc[$iso]);
                }
            }
        }

        if (!$iso) {
            return array_values($cc);
        }
        elseif ($code) {
            return (isset($cc[$code]))? $cc[$code] : null;
        }
        else {
            return $cc;
        }
    }


    /* static */ function get_states_opts($abbrs=true, $code=null) 
    {
        $a = array(
           'AL'=>'Alabama',
           'AK'=>'Alaska',
           'AZ'=>'Arizona',
           'AR'=>'Arkansas',
           'CA'=>'California',
           'CO'=>'Colorado',
           'CT'=>'Connecticut',
           'DE'=>'Delaware',
           'DC'=>'District of Columbia',
           'FL'=>'Florida',
           'GA'=>'Georgia',
           'HI'=>'Hawaii',
           'ID'=>'Idaho',
           'IL'=>'Illinois',
           'IN'=>'Indiana',
           'IA'=>'Iowa',
           'KS'=>'Kansas',
           'KY'=>'Kentucky',
           'LA'=>'Louisiana',
           'ME'=>'Maine',
           'MD'=>'Maryland',
           'MA'=>'Massachusetts',
           'MI'=>'Michigan',
           'MN'=>'Minnesota',
           'MS'=>'Mississippi',
           'MO'=>'Missouri',
           'MT'=>'Montana',
           'NE'=>'Nebraska',
           'NV'=>'Nevada',
           'NH'=>'New Hampshire',
           'NJ'=>'New Jersey',
           'NM'=>'New Mexico',
           'NY'=>'New York',
           'NC'=>'North Carolina',
           'ND'=>'North Dakota',
           'OH'=>'Ohio',
           'OK'=>'Oklahoma',
           'OR'=>'Oregon',
           'PA'=>'Pennsylvania',
           'RI'=>'Rhode Island',
           'SC'=>'South Carolina',
           'SD'=>'South Dakota',
           'TN'=>'Tennessee',
           'TX'=>'Texas',
           'UT'=>'Utah',
           'VT'=>'Vermont',
           'VA'=>'Virginia',
           'WA'=>'Washington',
           'WV'=>'West Virginia',
           'WI'=>'Wisconsin',
           'WY'=>'Wyoming'
        );

        if ($code) {
            return (isset($a[$code]))? $a[$code] : null;
        }
        else {
            return ($abbrs)? $a : $this->_array_stringify(array_values($a));
        }
    }

    /* static */ function get_canadian_provs($abbrs=true, $code=null) 
    {
        $a = array(
        "AB" => "Alberta",
        "BC" => "British Columbia",
        "MB" => "Manitoba",
        "NB" => "New Brunswick",
        "NF" => "Newfoundland",
        "NT" => "Northwest Territories",
        "NS" => "Nova Scotia",
        "ON" => "Ontario ",
        "PE" => "Prince Edward Island",
        "QC" => "Qu&eacute;bec",
        "SK" => "Sakatchewan ",
        "YT" => "Yukon",
        );
        if ($code) {
            return (isset($a[$code]))? $a[$code] : null;
        }
        else {
            return ($abbrs)? $a : $this->_array_stringify(array_values($a));
        }
    }

}

?>
